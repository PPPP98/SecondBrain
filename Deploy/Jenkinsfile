// Common helpers
@NonCPS
def clipText(String s, int maxLen = 600) {
  if (!s) return ""
  return s.size() > maxLen ? (s.take(maxLen) + "\n... (truncated)") : s
}

def mmNotify(Map m = [:]) {
  // m: [status: success|failure|info, template: merge_open|merge_success|failure|plain,
  //     category, title, url, targetBranch, assignee, reviewer, extra]
  def userMap = [
    'nks3319': 'hro',
  ]

  def status = (m.status ?: 'info').toLowerCase()
  def color = status == 'success' ? 'good' : (status == 'failure' ? 'danger' : '#888888')
  def title = m.title ?: (env.GL_MR_TITLE ?: 'No title')
  def url = m.url ?: (env.GL_MR_URL ?: env.BUILD_URL)
  def target = m.targetBranch ?: (env.GL_MR_TARGET ?: 'develop')
  
  def rawAssign = m.assignee ?: (env.GL_ASSIGNEE ?: '9526yu')
  def rawReviewer = m.reviewer ?: (env.GL_REVIEWER ?: '9526yu')

  def assign = userMap.get(rawAssign, rawAssign)
  def reviewer = userMap.get(rawReviewer, rawReviewer)

  def extra = m.extra ? "\n" + m.extra : ""

  String body
  switch ((m.template ?: 'plain')) {
    case 'merge_success':
      body = """
#### :homer_bush: Successfully Merged :homer_bush:

##### [${title}](${url})
:pencil2: **Assignee**: @${assign}

:gun_cat: **Target**: `${target}`

##### Pipeline Success!
---
##### ÏÑúÎπÑÏä§ Ï†êÍ≤ÄÌïòÎü¨ Í∞ÄÍ∏∞
:springboot: [Backend Spring Server](https://api.brainsecond.site/swagger-ui/index.html)
:fastapi: [FastAPI Server](https://api.brainsecond.site/ai/docs)
:react: [Frontend React Server](https://brainsecond.site)

##### Tools
:redis: [RedisInsight](https://brainsecond.site/redis/)
:neo: [Neo4j UI](https://brainsecond.site/neo4j/browser/)
:elasticsearch: [Kibana Dashboard](https://brainsecond.site/kibana/)
:rabbit_sleep: [RabbitMQ Management](https://brainsecond.site/rabbitmq/)
:grafana: [Grafana Dashboard](https://brainsecond.site/grafana/)

${extra}
"""
      break
    case 'merge_open':
      body = """
#### :green_frog: `${env.GL_USER_NAME ?: 'E107'}` MR Generated!!!!!!!!! :green_frog:

##### [${title}](${url})
*ÏÑúÎëòÎü¨ÏÑú ÏΩîÎìú Î¶¨Î∑∞ Ìï¥Ï£ºÏÑ∏Ïöî~! ÏàòÏ†ï ÌïÑÏöîÌï† Í≤ΩÏö∞ ÏûëÏÑ±Ïûê ÌÉúÍ∑∏Ìï¥Ï£ºÏÑ∏Ïöî!!*
:pencil2: **Assignee**: @${assign}
:eyes_5s: **Reviewer**: @${reviewer}

:gun_cat: **Target**: `${target}`

##### Pipeline Success!
${extra}
"""
      break
    case 'failure':
      body = """
#### :x: Jenkins Pipeline Failed :x:

##### [${title}](${url})
:pencil2: **Assignee**: @${assign}
:gun_cat: **Target**: `${target}`
---
##### Error
${extra}
"""
      break
    default:
      body = """
#### ${ status == 'success' ? ':white_check_mark:' : (status == 'failure' ? ':x:' : ':information_source:') } ${(m.category ?: 'INFO').toUpperCase()}
**[${title}](${url})**
:label: **Target**: `${target}`
:pencil2: **Assignee**: @${assign}
${extra}
"""
  }

  withCredentials([string(credentialsId: 'MM_WEBHOOK', variable: 'MM_WEBHOOK')]) {
    mattermostSend(endpoint: MM_WEBHOOK, channel: 'mr-e107', color: color, message: body)
  }
}

// Pipeline
pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    timeout(time: 60, unit: 'MINUTES')
  }

  parameters {
    string(name: 'GIT_PAT_CRED_ID',  defaultValue: 'seok', description: 'Jenkins credentialsId for GitLab PAT (Username/Password)')
    string(name: 'GIT_URL_HTTPS', defaultValue: 'https://lab.ssafy.com/s13-final/S13P31E107.git', description: 'Git repository (HTTPS)')
    string(name: 'DEVELOP_BRANCH', defaultValue: 'develop', description: 'Develop branch name')
    string(name: 'RELEASE_BRANCH', defaultValue: 'master', description: 'Release branch name')
    string(name: 'COMPOSE_FILE',   defaultValue: 'Deploy/docker-compose.yml', description: 'Main compose file')
    string(name: 'BACK_SERVICE',  defaultValue: 'klp_back',  description: 'Compose service name for backend (base name)')
    string(name: 'FRONT_SERVICE', defaultValue: 'klp_front', description: 'Compose service name for frontend (base name)')
    string(name: 'AI_SERVICE',    defaultValue: 'klp_ai',    description: 'Compose service name for ai (base name)')
    string(name: 'BACK_DIR',  defaultValue: 'backend/secondbrain', description: 'Backend root dir')
    string(name: 'FRONT_DIR', defaultValue: 'frontend/secondbrain', description: 'Frontend root dir')
    string(name: 'AI_DIR',    defaultValue: 'knowledge-graph-service', description: 'AI root dir')
  }

  triggers {
    GenericTrigger(
      genericVariables: [
        [key:'GL_EVENT',        value:'$.object_kind'],
        [key:'GL_MR_ACTION',    value:'$.object_attributes.action'],
        [key:'GL_MR_STATE',     value:'$.object_attributes.state'],
        [key:'GL_MR_TITLE',     value:'$.object_attributes.title'],
        [key:'GL_MR_SOURCE',    value:'$.object_attributes.source_branch'],
        [key:'GL_MR_TARGET',    value:'$.object_attributes.target_branch'],
        [key:'GL_MR_IID',       value:'$.object_attributes.iid'],
        [key:'GL_PROJECT',      value:'$.project.path_with_namespace'],
        [key:'GL_MR_SHA',       value:'$.object_attributes.last_commit.id'],
        [key:'GL_MR_URL',       value:'$.object_attributes.url'],
        [key:'GL_ASSIGNEE',     value:'$.assignees[0].username'],
        [key:'GL_REVIEWER',     value:'$.reviewers[0].username'],
        [key:'GL_USER_NAME',    value:'$.user.name']
      ],
      token: 'uknow-mr',
      printContributedVariables: false,
      printPostContent: false,
      regexpFilterText: '$GL_EVENT:$GL_MR_ACTION',
      regexpFilterExpression: '^merge_request:(open|reopen|merge|update)$'
    )
  }

  environment {
    GIT_URL_HTTPS   = "${params.GIT_URL_HTTPS}"
    GIT_CREDS_HTTPS = "${params.GIT_PAT_CRED_ID}"
    DEVELOP_BRANCH  = "${params.DEVELOP_BRANCH}"
    RELEASE_BRANCH  = "${params.RELEASE_BRANCH}"
    COMPOSE_FILE    = "${params.COMPOSE_FILE}"
    BACK_SERVICE    = "${params.BACK_SERVICE}"
    FRONT_SERVICE   = "${params.FRONT_SERVICE}"
    AI_SERVICE      = "${params.AI_SERVICE}"
    BACK_DIR        = "${params.BACK_DIR}"
    FRONT_DIR       = "${params.FRONT_DIR}"
    AI_DIR          = "${params.AI_DIR}"

    // Blue/Green Í¥ÄÎ†®
    ACTIVE_COLOR_FILE     = '/etc/nginx/snippets/active-color.conf'  // nginx Ïª®ÌÖåÏù¥ÎÑà Í∏∞Ï§Ä active color ÌååÏùº
    NGINX_CONTAINER       = 'nginx'
    // trueÎ©¥ 2Ï∞® Post-deploy Ìó¨Ïä§Ï≤¥ÌÅ¨ + ÏûêÎèô Î°§Î∞± Ïä§ÌÖåÏù¥ÏßÄ Ïã§Ìñâ
    ENABLE_LIVE_ROLLBACK  = 'true'
  }

  stages {

    stage('Validate Environment') {
      steps {
        sh '''
          set -eu
          [ -n "${GL_EVENT:-}" ]      || { echo "GL_EVENT is required"; exit 1; }
          [ -n "${GL_MR_ACTION:-}" ]  || { echo "GL_MR_ACTION is required"; exit 1; }
          [ -n "${GL_MR_TITLE:-}" ]   || { echo "GL_MR_TITLE is required"; exit 1; }
          [ -n "${GL_MR_SOURCE:-}" ]  || { echo "GL_MR_SOURCE is required"; exit 1; }
          [ -n "${GL_MR_TARGET:-}" ]  || { echo "GL_MR_TARGET is required"; exit 1; }
        '''
      }
    }

    stage('Checkout') {
      steps {
        script {
          try {
            def action = (env.GL_MR_ACTION ?: "").toLowerCase()
            def state  = (env.GL_MR_STATE  ?: "").toLowerCase()

            def src = env.GL_MR_SOURCE ?: env.DEVELOP_BRANCH
            def tgt = env.GL_MR_TARGET ?: env.DEVELOP_BRANCH

            def branchToCheckout
            if (action == "merge" && state == "merged") {
              branchToCheckout = tgt
              echo "Merged MR detected. Checkout TARGET branch: ${branchToCheckout}"
            } else {
              branchToCheckout = src
              echo "Non-merged MR. Checkout SOURCE branch: ${branchToCheckout}"
            }

            checkout([$class: 'GitSCM',
              branches: [[name: "*/${branchToCheckout}"]],
              userRemoteConfigs: [[
                url: env.GIT_URL_HTTPS,
                credentialsId: env.GIT_CREDS_HTTPS
              ]]
            ])

            sh '''
              set -eu
              git branch --show-current || true
              git log -1 --oneline || true
            '''
          } catch (e) {
            mmNotify(status:'failure', category:'checkout', template:'failure', extra: "checkout failed")
            error "Checkout failed: ${e}"
          }
        }
      }
    }

    stage('Load conventions & Validate MR title') {
      steps {
        script {
          try {
            sh '''
              set -eu
              MR_TITLE_COMMON='^(\\[üîÄ\\s+(FE|BE|INFRA|AI)\\]|\\[‚õëÔ∏è\\s+(FE|BE|INFRA|AI)\\]|\\[üõ´\\s+(FE|BE|INFRA|AI)\\])\\s+.+$'
              MR_TITLE_DEV='^\\[üîÄ\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              MR_TITLE_HOT='^\\[‚õëÔ∏è\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              MR_TITLE_REL='^\\[üõ´\\s+(FE|BE|INFRA|AI)\\]\\s+.+$'
              RELEASE_REGEX='v[0-9]+\\.[0-9]+\\.[0-9]+(-\\S+)?$'
              {
                echo "MR_TITLE_COMMON='${MR_TITLE_COMMON}'"
                echo "MR_TITLE_DEV='${MR_TITLE_DEV}'"
                echo "MR_TITLE_HOT='${MR_TITLE_HOT}'"
                echo "MR_TITLE_REL='${MR_TITLE_REL}'"
                echo "RELEASE_REGEX='${RELEASE_REGEX}'"
              } > .conventions.env
            '''
            sh '''
              set -eu
              . ./.conventions.env
              TITLE="${GL_MR_TITLE}"
              echo "Validating MR title: $TITLE"
              echo "$TITLE" | grep -Pq "$MR_TITLE_COMMON" || { echo "‚ùå Not matching common pattern"; exit 4; }
              echo "‚úÖ MR title OK"
            '''

            def action = (env.GL_MR_ACTION ?: "").toLowerCase()
            if (action == "open" || action == "reopen") {
              mmNotify(status:'success', category:'mr-open', template:'merge_open')
            }
          } catch (e) {
            mmNotify(status:'failure', category:'mr-title', template:'failure', extra: "MR title validation failed")
            error "MR title validation failed: ${e}"
          }
        }
      }
    }

    stage('Detect changes') {
      steps {
        script {
          try {
            def srcBranch = (env.GL_MR_SOURCE ?: "").toLowerCase()
            echo "Detect by branch name only: ${srcBranch}"

            def isBE = (srcBranch =~ /(^|\/)(be)(\/|$)/)
            def isFE = (srcBranch =~ /(^|\/)(fe)(\/|$)/)
            def isAI = (srcBranch =~ /(^|\/)(ai)(\/|$)/)
            def isINFRA = (srcBranch =~ /(^|\/)(infra)(\/|$)/)

            env.CHANGED_BACK   = (isBE || isINFRA) ? "1" : "0"
            env.CHANGED_FRONT  = (isFE || isINFRA) ? "1" : "0"
            env.CHANGED_AI     = (isAI || isINFRA) ? "1" : "0"
            env.CHANGED_DEPLOY = isINFRA ? "1" : "0"

            echo "RESULT | BACK:${env.CHANGED_BACK}, FRONT:${env.CHANGED_FRONT}, AI:${env.CHANGED_AI}, INFRA:${env.CHANGED_DEPLOY}"
          } catch (e) {
            mmNotify(status:'failure', category:'change-detect', template:'failure', extra: "Change detection failed")
            error "Change detection failed: ${e}"
          }
        }
      }
    }

    stage('Report status to GitLab (title check)') {
      when { expression { (env.GL_MR_ACTION ?: "") != "merge" } }
      steps {
        script {
          try {
            withCredentials([usernamePassword(credentialsId: env.GIT_CREDS_HTTPS, usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
              sh '''
                set -eu
                SHA="${GL_MR_SHA:-}"
                [ -n "$SHA" ] || { echo "No MR last_commit SHA to report"; exit 0; }
                CONTEXT="jenkins:mr-title-check"
                DESC="MR title check passed"
                TARGET="${BUILD_URL:-}"
                PROJECT_ENC="$(printf '%s' "${GL_PROJECT:-}" | sed 's#/#%2F#g')"
                curl -sS -X POST \
                  -H "PRIVATE-TOKEN: ${GIT_PASS}" \
                  "https://lab.ssafy.com/api/v4/projects/${PROJECT_ENC}/statuses/${SHA}" \
                  --fail \
                  --data "state=success&context=${CONTEXT}&description=${DESC}&target_url=${TARGET}"
              '''
            }
          } catch (e) {
            mmNotify(status:'failure', category:'gitlab-status', template:'failure', extra: "GitLab status report failed")
          }
        }
      }
    }

    stage('Prepare env file (for deploy)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" && (env.GL_MR_STATE ?: "") == "merged")
        }
      }
      steps {
        script {
          try {
            withCredentials([file(credentialsId: 'ENV_FILE', variable: 'ENV_FILE')]) {
              sh '''
                set -eu
                install -m 600 "$ENV_FILE" Deploy/.env
              '''
            }
          } catch (e) {
            mmNotify(status:'failure', category:'prepare-env', template:'failure', extra: "Prepare env failed")
            error "Prepare env failed: ${e}"
          }
        }
      }
    }

    stage('Docker Image Push to DockerHub (changed only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" || (env.GL_MR_STATE ?: "") == "merged") &&
          (env.GL_MR_TARGET == env.RELEASE_BRANCH)
        }
      }
      environment {
        IMG_SHA = "${(env.GL_MR_SHA ?: env.GIT_COMMIT ?: 'manual').take(12)}"
      }
      steps {
        withCredentials([
          usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')
        ]) {
          script {
            def targets = [
              [flag: env.CHANGED_BACK,  name: 'backend',  ctx: env.BACK_DIR,  df: 'Dockerfile', image: 'seok1419/klp-backend'],
              [flag: env.CHANGED_FRONT, name: 'frontend', ctx: env.FRONT_DIR, df: 'Dockerfile', image: 'seok1419/klp-frontend'],
              [flag: env.CHANGED_AI,    name: 'ai',       ctx: env.AI_DIR,    df: 'Dockerfile', image: 'seok1419/klp-ai']
            ]

            sh "echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin"

            def anyPushed = false
            targets.each { t ->
              if (t.flag == "1") {
                anyPushed = true
                sh """
                  set -eu
                  export DOCKER_BUILDKIT=1
                  test -d "${t.ctx}"
                  test -f "${t.ctx}/${t.df}"

                  docker build --pull \
                    -t "${t.image}:${IMG_SHA}" \
                    -f "${t.ctx}/${t.df}" \
                    "${t.ctx}"

                  docker tag "${t.image}:${IMG_SHA}" "${t.image}:latest"
                  docker push "${t.image}:${IMG_SHA}"
                  docker push "${t.image}:latest"
                """
              } else {
                echo "Skip Docker build/push for ${t.name} (no changes)"
              }
            }

            sh '''
              docker logout || true
              docker image prune -f || true
            '''

            if (!anyPushed) {
              echo "No image to push."
            }
          }
        }
      }
    }

    // Blue/Green Î¨¥Ï§ëÎã® Î∞∞Ìè¨ Î∞è Ìó¨Ïä§Ï≤¥ÌÅ¨ 1Ï∞®
    stage('Deploy (Blue/Green ‚Äî changed services only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" && (env.GL_MR_STATE ?: "") == "merged")
        }
      }
      steps {
        script {
          try {
            timeout(time: 20, unit: 'MINUTES') {
              def anyChanged = (env.CHANGED_BACK == "1" ||
                                env.CHANGED_FRONT == "1" ||
                                env.CHANGED_AI == "1" ||
                                env.CHANGED_DEPLOY == "1")

              if (!anyChanged) {
                echo "No relevant changes ‚Äî nothing to deploy."
                return
              }

              // ÌòÑÏû¨ ÏÉâ ÏùΩÍ≥† NEXT_COLOR Í≥ÑÏÇ∞
              def conf = sh(
                script: '''
                  if docker exec "$NGINX_CONTAINER" test -f "$ACTIVE_COLOR_FILE"; then
                    docker exec "$NGINX_CONTAINER" cat "$ACTIVE_COLOR_FILE"
                  else
                    echo 'set $active_color blue;'
                  fi
                ''',
                returnStdout: true
              ).trim()

              echo "active-color.conf content = '${conf}'"

              String line
              def lines = conf.readLines()
              if (lines.isEmpty()) {
                line = "set \$active_color blue;"
              } else {
                line = lines.find { it.contains("active_color") } ?: lines.last()
              }

              echo "parsed line = '${line}'"

              def tokens = line.trim().split(/\s+/)
              def lastToken = tokens ? tokens[-1] : "blue;"
              def currentColor = lastToken.replace(";", "")

              if (!(currentColor in ["blue", "green"])) {
                echo "Unknown color '${currentColor}', fallback to blue"
                currentColor = "blue"
              }

              env.CURRENT_COLOR = currentColor
              env.NEXT_COLOR    = (currentColor == 'blue') ? 'green' : 'blue'

              echo "CURRENT_COLOR = ${env.CURRENT_COLOR}"
              echo "NEXT_COLOR    = ${env.NEXT_COLOR}"

              // Í≥µÌÜµ docker compose pull
              sh '''
                set -eux
                docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" pull || true
              '''

              // Blue/GreenÏö© Ïã§Ï†ú ÏÑúÎπÑÏä§ Ïù¥Î¶Ñ
              def nextBackService  = "klp_back_${env.NEXT_COLOR}"
              def nextFrontService = "klp_front_${env.NEXT_COLOR}"
              def nextAiService    = "klp_ai_${env.NEXT_COLOR}"

              // Ïñ¥Îñ§ ÏÑúÎπÑÏä§Í∞Ä ÎπåÎìúÍπåÏßÄ ÌïÑÏöîÌïúÏßÄ Í≥ÑÏÇ∞
              def changedBack  = (env.CHANGED_BACK  == "1" || env.CHANGED_DEPLOY == "1")
              def changedFront = (env.CHANGED_FRONT == "1" || env.CHANGED_DEPLOY == "1")
              def changedAi    = (env.CHANGED_AI    == "1")

              // Backend
              if (changedBack) {
                echo "Deploying (build) backend: ${nextBackService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextBackService}
                """
              } else {
                echo "Backend not changed ‚Äî ensure ${nextBackService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextBackService}
                """
              }

              // Frontend
              if (changedFront) {
                echo "Deploying (build) frontend: ${nextFrontService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextFrontService}
                """
              } else {
                echo "Frontend not changed ‚Äî ensure ${nextFrontService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextFrontService}
                """
              }

              // AI
              if (changedAi) {
                echo "Deploying (build) AI: ${nextAiService}"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextAiService}
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build note_consumer
                """
              } else {
                echo "AI not changed ‚Äî ensure ${nextAiService} is up without rebuild"
                sh """
                  set -eux
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build ${nextAiService}
                  docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d --build note_consumer
                """
              }

              // NEXT_COLOR Ïä§ÌÉù Ìó¨Ïä§Ï≤¥ÌÅ¨ (HTTP 200)
              def maxAttempts   = 10
              def sleepSeconds  = 10
              def ok = false

              for (int i = 1; i <= maxAttempts; i++) {
                echo "Health check attempt ${i}/${maxAttempts} on color=${env.NEXT_COLOR}"

                def backOk = sh(
                  script: "curl -fsS http://127.0.0.1:8080/health || echo FAIL",
                  returnStdout: true
                ).trim()

                def aiOk = sh(
                  script: "curl -fsS http://klp_ai_${env.NEXT_COLOR}:8000/ai/health || echo FAIL",
                  returnStdout: true
                ).trim()

                def frontOk = sh(
                  script: "curl -fsS http://klp_front_${env.NEXT_COLOR}/health || echo FAIL",
                  returnStdout: true
                ).trim()

                echo "backOk=${backOk}, aiOk=${aiOk}, frontOk=${frontOk}"

                if (!backOk.contains("FAIL") && !aiOk.contains("FAIL") && !frontOk.contains("FAIL")) {
                  ok = true
                  break
                }
                sleep sleepSeconds
              }

              if (!ok) {
                error "NEXT_COLOR (${env.NEXT_COLOR}) stack health check failed (container-level)"
              }

              // Nginx Ìä∏ÎûòÌîΩÏùÑ NEXT_COLORÎ°ú Ïä§ÏúÑÏπò
              sh '''
                set -eux
                docker exec "$NGINX_CONTAINER" /bin/sh -c "printf 'set \\$active_color %s;\\n' \"$NEXT_COLOR\" > \"$ACTIVE_COLOR_FILE\" && nginx -s reload"
              '''

              // Ïù¥Ï†Ñ ÏÉâ Ïä§ÌÉùÏùÄ Ìï≠ÏÉÅ Ïú†ÏßÄ (Blue/Green Ïù¥Ï†ê + Î°§Î∞± ÎåÄÎπÑ)
              if (env.CURRENT_COLOR) {
                echo "Keep previous color ${env.CURRENT_COLOR} running for Blue/Green & rollback"
              } else {
                echo "No CURRENT_COLOR set (first deploy?) - skip stopping old color"
              }
            }
            mmNotify(status:'success', category:'deploy', template:'merge_success', targetBranch: env.GL_MR_TARGET)
          } catch (e) {
            mmNotify(status:'failure', category:'deploy', template:'failure', targetBranch: env.GL_MR_TARGET, extra: "Deploy failed")
            error "Deploy failed: ${e}"
          }
        }
      }
    }

    // 2Ï∞® Post-deploy Ìó¨Ïä§Ï≤¥ÌÅ¨ + ÏûêÎèô Î°§Î∞±
    stage('Post-deploy health check & rollback') {
      when {
        expression {
          (env.GL_MR_ACTION ?: "") == "merge" &&
          (env.GL_MR_STATE  ?: "") == "merged" &&
          env.ENABLE_LIVE_ROLLBACK?.toBoolean()
        }
      }
      steps {
        script {
          // ÌòÑÏû¨ active_color Ïû¨ÌôïÏù∏ (ÌòπÏãú ÏàòÎèô Î≥ÄÍ≤Ω ÎåÄÎπÑ)
          def activeColor = sh(
            script: '''
              if docker exec "$NGINX_CONTAINER" test -f "$ACTIVE_COLOR_FILE"; then
                docker exec "$NGINX_CONTAINER" cat "$ACTIVE_COLOR_FILE"
              else
                echo 'set $active_color blue;'
              fi
            ''',
            returnStdout: true
          ).trim()

          echo "Post-deploy check: activeColor=${activeColor}, CURRENT_COLOR=${env.CURRENT_COLOR}, NEXT_COLOR=${env.NEXT_COLOR}"

          // NEXT_COLORÎ°ú Ï†ÑÌôòÎêú ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê Í≤ΩÏö∞, Ïó¨Í∏∞ÏÑúÎäî ÏïÑÎ¨¥ Í≤ÉÎèÑ Ïïà Ìï®
          if (activeColor != env.NEXT_COLOR) {
            echo "activeColor != NEXT_COLOR, skip post-deploy rollback check"
            return
          }

          // Ïô∏Î∂Ä ÎèÑÎ©îÏù∏ Í∏∞Ï§Ä Ìó¨Ïä§Ï≤¥ÌÅ¨
          def maxAttempts  = 5
          def sleepSeconds = 5
          def ok = false

          for (int i = 1; i <= maxAttempts; i++) {
            echo "Post-deploy health attempt ${i}/${maxAttempts}"

            def backStatus = sh(
              script: "curl -k -L -s -o /dev/null -w '%{http_code}' https://api.brainsecond.site/health || echo 000",
              returnStdout: true
            ).trim()

            def aiStatus = sh(
              script: "curl -k -L -s -o /dev/null -w '%{http_code}' https://api.brainsecond.site/ai/health || echo 000",
              returnStdout: true
            ).trim()

            def frontStatus = sh(
              script: "curl -k -L -s -o /dev/null -w '%{http_code}' https://brainsecond.site/health || echo 000",
              returnStdout: true
            ).trim()

            echo "live backStatus=${backStatus}, aiStatus=${aiStatus}, frontStatus=${frontStatus}"

            if (backStatus == "200" && aiStatus == "200" && frontStatus == "200") {
              ok = true
              break
            }
            sleep sleepSeconds
          }

          if (ok) {
            echo "Post-deploy live health check passed. No rollback required."
            return
          }

          // Ïó¨Í∏∞ÍπåÏßÄ ÏôîÏúºÎ©¥ live health Ïã§Ìå® ‚Üí Î°§Î∞± ÏãúÎèÑ
          if (!env.CURRENT_COLOR) {
            error "Post-deploy health failed, but CURRENT_COLOR is unknown. Cannot rollback automatically."
          }

          def rollbackColor = env.CURRENT_COLOR
          echo "Post-deploy health failed. Rolling back to previous color=${rollbackColor}"

          // Î°§Î∞± ÎåÄÏÉÅ ÏÉâ Ïä§ÌÉù ensure up (ÎπåÎìú ÏóÜÏù¥)
          sh """
            set -eux
            docker compose --env-file Deploy/.env -f "$COMPOSE_FILE" up -d \\
              klp_back_${rollbackColor} \\
              klp_front_${rollbackColor} \\
              klp_ai_${rollbackColor}
          """

          // Í∞ÑÎã® Ïª®ÌÖåÏù¥ÎÑà Ìó¨Ïä§Ï≤¥ÌÅ¨ (rollback ÎåÄÏÉÅ)
          def maxRollbackAttempts = 10
          def rollbackOk = false

          for (int i = 1; i <= maxRollbackAttempts; i++) {
            echo "Rollback target health attempt ${i}/${maxRollbackAttempts} on color=${rollbackColor}"

            def backStatus_rb = sh(
              script: """
                docker exec ${NGINX_CONTAINER} sh -c \\
                  "curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8080/health || echo 000"
              """,
              returnStdout: true
            ).trim()

            def aiStatus_rb = sh(
              script: """
                docker exec ${NGINX_CONTAINER} sh -c \\
                  "curl -s -o /dev/null -w '%{http_code}' http://klp_ai_${rollbackColor}:8000/ai/health || echo 000"
              """,
              returnStdout: true
            ).trim()

            def frontStatus_rb = sh(
              script: """
                docker exec ${NGINX_CONTAINER} sh -c \\
                  "curl -s -o /dev/null -w '%{http_code}' http://klp_front_${rollbackColor}/health || echo 000"
              """,
              returnStdout: true
            ).trim()

            echo "rollback backStatus_rb=${backStatus_rb}, aiStatus_rb=${aiStatus_rb}, frontStatus_rb=${frontStatus_rb}"

            if (backStatus_rb == "200" && aiStatus_rb == "200" && frontStatus_rb == "200") {
              rollbackOk = true
              break
            }
            sleep 10
          }

          if (!rollbackOk) {
            error "Rollback target color (${rollbackColor}) health check failed. Manual intervention required."
          }

          // NginxÎ•º Ïù¥Ï†Ñ ÏÉâÏúºÎ°ú ÎêòÎèåÎ¶¨Í∏∞
          sh '''
            set -eux
            docker exec "$NGINX_CONTAINER" /bin/sh -c "printf 'set \\$active_color %s;\\n' \"$NEXT_COLOR\" > \"$ACTIVE_COLOR_FILE\" && nginx -s reload"
          '''

          // NEXT_COLORÎäî ÏùºÎã® Í∑∏ÎåÄÎ°ú Îë¨ÏÑú ÏÇ¨ÌõÑ Î∂ÑÏÑù Í∞ÄÎä•
          error "Post-deploy live health check failed. Rolled back to color=${rollbackColor}."
        }
      }
    }

    stage('Tag & Push (release only)') {
      when {
        expression {
          ((env.GL_MR_ACTION ?: "") == "merge" || (env.GL_MR_STATE ?: "") == "merged") &&
          (env.GL_MR_TARGET == env.RELEASE_BRANCH)
        }
      }
      steps {
        script {
          try {
            withCredentials([usernamePassword(credentialsId: env.GIT_CREDS_HTTPS, usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
              sh '''
                set -eu
                . ./.conventions.env
                TITLE="${GL_MR_TITLE:-}"
                IID="${GL_MR_IID:-}"
                VERSION="$( echo "$TITLE" | grep -Po "$RELEASE_REGEX" | head -n1 || true )"
                [ -n "${VERSION:-}" ] || VERSION="release-$(date +%Y%m%d)-!${IID}"
                echo "üì¶ Tagging: ${VERSION}"

                git config user.email "9526yu@naver.com"
                git config user.name  "jungseokyu"

                BASE_URL="${GIT_URL_HTTPS}"
                case "$BASE_URL" in
                  https://*) : ;;
                  https//*)   BASE_URL="https://${BASE_URL#https//}" ;;
                  *)          BASE_URL="https://${BASE_URL#https://}" ;;
                esac

                git tag -a "${VERSION}" -m "Release ${VERSION}"
                git push "https://${GIT_USER}:${GIT_PASS}@${BASE_URL#https://}" "${VERSION}"
              '''
            }
            mmNotify(status:'success', category:'tagging')
          } catch (e) {
            mmNotify(status:'failure', category:'tagging', template:'failure', extra: "Tag & push failed")
            error "Tag & push failed: ${e}"
          }
        }
      }
    }
  }

  post {
    success {
      echo "ÏÑ±Í≥µÌñàÎã§ Íµ≥"
    }
    failure {
      echo "Ïã§Ìå®ÌñàÎã§ ÎÖ∏Ïö∞"
    }
    unstable {
      script {
        mmNotify(
          status:'info',
          category:'pipeline',
          extra: "Marked UNSTABLE: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        )
      }
    }
  }
}
