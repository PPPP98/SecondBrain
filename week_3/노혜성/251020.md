# Overriding & Overloading

오버라이딩(Overriding)은 상속 관계에서 부모 클래스의 메서드를 자식 클래스가 재정의하는 것을 말한다.
즉, 부모가 가진 메서드의 이름, 매개변수, 반환형이 모두 같지만 내부 구현만 다르게 바꿔서 사용하는 것이다.
이는 다형성을 구현하기 위한 핵심 개념으로, 자식 클래스가 부모의 동작을 자신의 방식으로 바꾸고자 할 때 사용된다.

반면 오버로딩(Overloading)은 같은 클래스 내에서 메서드 이름은 같지만 매개변수의 개수나 타입이 다를 때 여러 개의 메서드를 정의하는 것을 말한다.
이는 같은 기능을 하는 메서드를 다양한 입력 형태로 유연하게 사용할 수 있게 해준다. 오버로딩은 컴파일 시점에 어떤 메서드가 호출될지 결정되며(정적 바인딩), 오버라이딩은 실행 시점에 결정된다(동적 바인딩).

즉, 오버로딩은 컴파일타입 다형성, 오버라이딩은 런타임 다형성이라고 할 수 있다. 오버라이딩은 상속이 전제되어야 하지만, 오버로딩은 상속이 없어도 가능하다. 결과적으로 오버라이딩은 기존 기능을 새롭게 정의하는 것, 오버로딩은 하나의 이름으로 여러 기능을 확장하는 것이라고 설명할 수 있다.

---

## 오버로딩 상세

### Java 오버로딩 예제

Java에서는 메서드 이름이 같아도 매개변수의 타입이나 개수가 다르면 여러 메서드를 정의할 수 있다.

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```

생성자 오버로딩도 자주 사용된다.

```java
public class User {
    private String name;
    private String email;

    public User() {
        this.name = "Guest";
        this.email = "guest@example.com";
    }

    public User(String name) {
        this.name = name;
        this.email = name + "@example.com";
    }

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
}
```

### TypeScript 오버로딩 예제

TypeScript는 오버로드 시그니처를 선언하고 하나의 구현에서 모든 케이스를 처리한다.

```typescript
function attr(name: string): string;
function attr(name: string, value: string): Accessor;
function attr(map: any): Accessor;

function attr(nameOrMap: any, value?: string): any {
    if (nameOrMap && typeof nameOrMap === "object") {
        return new Accessor();
    } else if (value !== undefined) {
        return new Accessor();
    } else {
        return "string value";
    }
}
```

### 웹 개발 활용: API 요청 빌더

```typescript
class ApiRequestBuilder {
    request(path: string): Promise<any>;
    request(path: string, method: 'GET' | 'POST'): Promise<any>;
    request(path: string, method: string, body?: any): Promise<any>;

    async request(path: string, method: string = 'GET', body?: any): Promise<any> {
        const url = `https://api.example.com${path}`;
        const options: RequestInit = {
            method,
            headers: { 'Content-Type': 'application/json' }
        };

        if (body && method !== 'GET') {
            options.body = JSON.stringify(body);
        }

        const response = await fetch(url, options);
        return response.json();
    }
}

const api = new ApiRequestBuilder();
await api.request('/users');
await api.request('/users', 'POST', { name: 'Alice' });
```

### 웹 개발 활용: 폼 검증

```java
public class Validator {
    public boolean validate(String value) {
        return value != null && !value.trim().isEmpty();
    }

    public boolean validate(String value, int minLength) {
        return validate(value) && value.length() >= minLength;
    }

    public boolean validate(String value, int minLength, int maxLength) {
        return validate(value, minLength) && value.length() <= maxLength;
    }

    public boolean validate(int value, int min, int max) {
        return value >= min && value <= max;
    }
}

Validator validator = new Validator();
validator.validate(username, 3, 20);
validator.validate(age, 18, 100);
```

---

## 오버라이딩 상세

### Java 오버라이딩 예제

@Override 어노테이션을 사용하여 명시적으로 재정의함을 표시한다.

```java
public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println("동물 소리");
    }

    public String getName() {
        return name;
    }
}

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(getName() + ": 멍멍!");
    }
}

public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(getName() + ": 야옹~");
    }
}

Animal[] animals = { new Dog("바둑이"), new Cat("나비") };
for (Animal animal : animals) {
    animal.makeSound();
}
```

### TypeScript 오버라이딩 예제

추상 클래스를 사용하여 자식 클래스가 반드시 구현하도록 강제할 수 있다.

```typescript
abstract class Shape {
    constructor(protected color: string) {}

    abstract calculateArea(): number;
    abstract calculatePerimeter(): number;

    describe(): string {
        return `This is a ${this.color} shape`;
    }
}

class Circle extends Shape {
    constructor(color: string, private radius: number) {
        super(color);
    }

    calculateArea(): number {
        return Math.PI * this.radius ** 2;
    }

    calculatePerimeter(): number {
        return 2 * Math.PI * this.radius;
    }

    describe(): string {
        return `${super.describe()} with radius ${this.radius}`;
    }
}

const shapes: Shape[] = [new Circle('red', 5)];
shapes.forEach(s => console.log(s.calculateArea()));
```

### 웹 개발 활용: 결제 시스템

```typescript
abstract class PaymentProcessor {
    constructor(protected amount: number) {}

    async processPayment(): Promise<PaymentResult> {
        try {
            await this.validatePayment();
            const result = await this.executePayment();
            await this.logTransaction(result);
            return result;
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    protected async validatePayment(): Promise<void> {
        if (this.amount <= 0) {
            throw new Error('결제 금액은 0보다 커야 합니다.');
        }
    }

    protected abstract executePayment(): Promise<PaymentResult>;

    protected async logTransaction(result: PaymentResult): Promise<void> {
        console.log(`Transaction: ${JSON.stringify(result)}`);
    }
}

class CreditCardPayment extends PaymentProcessor {
    constructor(amount: number, private cardNumber: string) {
        super(amount);
    }

    protected async validatePayment(): Promise<void> {
        await super.validatePayment();
        if (this.cardNumber.length !== 16) {
            throw new Error('카드 번호는 16자리여야 합니다.');
        }
    }

    protected async executePayment(): Promise<PaymentResult> {
        return {
            success: true,
            transactionId: `CC-${Date.now()}`,
            method: 'credit_card',
            amount: this.amount
        };
    }
}

class PayPalPayment extends PaymentProcessor {
    constructor(amount: number, private email: string) {
        super(amount);
    }

    protected async executePayment(): Promise<PaymentResult> {
        return {
            success: true,
            transactionId: `PP-${Date.now()}`,
            method: 'paypal',
            amount: this.amount
        };
    }
}
```

### 웹 개발 활용: 인증 전략

```java
public abstract class AuthenticationStrategy {
    protected String userId;

    public final AuthResult authenticate(String credentials) {
        try {
            parseCredentials(credentials);
            boolean isValid = validateCredentials();

            if (!isValid) {
                return new AuthResult(false, "Invalid credentials", null);
            }

            User user = loadUserInfo();
            String token = generateToken(user);
            return new AuthResult(true, "Success", token);
        } catch (Exception e) {
            return new AuthResult(false, e.getMessage(), null);
        }
    }

    protected abstract void parseCredentials(String credentials);
    protected abstract boolean validateCredentials();
    protected abstract User loadUserInfo();

    protected String generateToken(User user) {
        return "TOKEN-" + user.getId() + "-" + System.currentTimeMillis();
    }
}

public class JWTAuthStrategy extends AuthenticationStrategy {
    private String token;

    @Override
    protected void parseCredentials(String credentials) {
        this.token = credentials.replace("Bearer ", "");
    }

    @Override
    protected boolean validateCredentials() {
        return token != null && token.split("\\.").length == 3;
    }

    @Override
    protected User loadUserInfo() {
        return new User(userId, "Alice", "alice@example.com");
    }
}

public class BasicAuthStrategy extends AuthenticationStrategy {
    private String username;
    private String password;

    @Override
    protected void parseCredentials(String credentials) {
        String decoded = new String(Base64.getDecoder()
            .decode(credentials.replace("Basic ", "")));
        String[] parts = decoded.split(":");
        this.username = parts[0];
        this.password = parts[1];
    }

    @Override
    protected boolean validateCredentials() {
        return username != null && password.length() >= 8;
    }

    @Override
    protected User loadUserInfo() {
        return new User(username, username, username + "@example.com");
    }
}
```

---

## 정리

오버로딩은 같은 이름의 메서드를 매개변수에 따라 다르게 정의하여 편의성을 제공한다. 컴파일 시점에 결정되며 API 요청 빌더나 폼 검증 같은 곳에서 유용하다.

오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하여 다형성을 구현한다. 런타임에 결정되며 결제 시스템이나 인증 전략처럼 여러 구현체가 같은 인터페이스를 공유해야 할 때 필수적이다.

두 개념 모두 웹 애플리케이션 개발에서 코드의 유지보수성과 확장성을 크게 향상시킨다.
